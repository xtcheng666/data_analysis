# Day1
# 1.NumPy的ndarray:一种多维数组对象
# 创建ndarray

以一个列表的转换为例


```python
import numpy as np
```


```python
data1 = [6,7.5,8,0,1]
```


```python
arr1 = np.array(data1)
arr1
```




    array([6. , 7.5, 8. , 0. , 1. ])



嵌套序列（比如由一组等长列表组成的列表）将会被转换为一个多维数组


```python
data2 = [[1,2,3,4],[5,6,7,8]]
```


```python
arr2 = np.array(data2)
arr2
```




    array([[1, 2, 3, 4],
           [5, 6, 7, 8]])




```python
arr2.ndim  # 返回数组维度
```




    2




```python
arr2.shape  # 表示各位维度大小的元组。返回的是一个元组
```




    (2, 4)




```python
arr1.dtype
```




    dtype('float64')




```python
arr2.dtype
```




    dtype('int32')



除了np.array还有一些函数可以创建数组，如zeros和ones可以创建指定长度或形状全0或全1数组。
empty可以创建一个没有任何具体值的数组。


```python
np.zeros(10)
```




    array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0.])




```python
np.zeros((3,6))
```




    array([[0., 0., 0., 0., 0., 0.],
           [0., 0., 0., 0., 0., 0.],
           [0., 0., 0., 0., 0., 0.]])




```python
np.empty((2,3,2))   # 返回的是一些未初始化的垃圾值
```




    array([[[1.28720595e-311, 2.47032823e-322],
            [0.00000000e+000, 0.00000000e+000],
            [0.00000000e+000, 8.60952352e-072]],
    
           [[6.81137280e-091, 2.21378155e-052],
            [3.60957848e+174, 1.16350629e+165],
            [3.99910963e+252, 1.46030983e-319]]])



arange是[python内置函数range]的数组版


```python
np.arange(15)
```




    array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14])




```python
np.array([[1,2,3],[2,3,4]])
```




    array([[1, 2, 3],
           [2, 3, 4]])



# ndarray的数据类型
dtype(数据类型)是一个特殊的对象，它含有ndarray将一块内存解释为特定数据类型所需的信息:


```python
arr1=np.array([1,2,3],dtype=np.float64)
arr2=np.array([1,2,3],dtype=np.int32)
```


```python
arr1.dtype
```




    dtype('float64')




```python
arr2.dtype
```




    dtype('int32')



可以使用ndarray的astype方法显式的转换其dtype
下为例子


```python
arr=np.array([1,2,3,4,5])
arr.dtype
```




    dtype('int32')




```python
arr
```




    array([1, 2, 3, 4, 5])




```python
float_arr = arr.astype(np.float64)
float_arr.dtype
```




    dtype('float64')




```python
float_arr
```




    array([1., 2., 3., 4., 5.])




```python
arr # astype转换类型是创建了一个新的ndarray，需要用变量接收
```




    array([1, 2, 3, 4, 5])



例2，如果字符串数组表示的全是数字，则也可以用astype转换


```python
numeric_string=np.array(['1.2','2.11','4.75'],dtype=np.string_)
numeric_string.astype(float) # np.float64
```




    array([1.2 , 2.11, 4.75])



强制转换时，astype（）括号里可以写另一个ndarray.dtype表示转换成他的类型，如：


```python
int_array=np.arange(10)
int_array
```




    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])




```python
calibers = np.array([.22,.270,.414],dtype =np.float64)
```


```python
int_array.astype(calibers.dtype)
```




    array([0., 1., 2., 3., 4., 5., 6., 7., 8., 9.])



也可以用简洁的类型代码来表示dtype，如：int32-i4  uint32-u4


```python
empty_uint32 = np.empty((3,2),dtype='u4')
empty_uint32
```




    array([[ 858993459, 1072902963],
           [2920577761, 1073799495],
           [         0, 1074987008]], dtype=uint32)



# 数组和标量之间的运算
大小相等的数组之间的任何算术运算都会将运算应用到元素级


```python
arr = np.array([[1.,2.,3.],[4.,5.,6.]])
arr
```




    array([[1., 2., 3.],
           [4., 5., 6.]])




```python
arr*arr
```




    array([[ 1.,  4.,  9.],
           [16., 25., 36.]])




```python
arr-arr
```




    array([[0., 0., 0.],
           [0., 0., 0.]])




```python
arr*0.5
```




    array([[0.5, 1. , 1.5],
           [2. , 2.5, 3. ]])




```python
1/arr   # 0.5 ，1这种叫做标量
```




    array([[1.        , 0.5       , 0.33333333],
           [0.25      , 0.2       , 0.16666667]])



不同大小的数组之间的运算叫做广播，第12章中详讲

# 基本的索引和切片
Numpy数组的索引内容很多，因为选取数据子集或单个元素的方式有很多。一维数组很简单，从表面上看，他跟python的列表的功能差不多


```python
arr = np.arange(10)
arr
```




    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])




```python
arr[5]
```




    5




```python
arr[5:8]
```




    array([5, 6, 7])




```python
arr[5:8]=12
arr
```




    array([ 0,  1,  2,  3,  4, 12, 12, 12,  8,  9])



可见，把一个标量赋值给一个切片时，该值会自动传播(即广播)到整个选区。
### 此外，跟列表最重要的区别在于，数组切片是原始数组的视图。这意味着数据不会被复制，视图上
### 任何修改都会直接反映到源数组上:


```python
arr_slice = arr[5:8]
```


```python
arr_slice[1]=1234
arr
```




    array([   0,    1,    2,    3,    4,   12, 1234,   12,    8,    9])




```python
arr_slice[:] = 64
arr
```




    array([ 0,  1,  2,  3,  4, 64, 64, 64,  8,  9])



Numpy用于处理大数据，所以不把数据复制来复制去
waring：如果你想得到的是ndarray切片的一份副本而非视图，就需要显式的进行复制操作
如： arr[5:8].copy()

对于高维度数组中，如二维数组，各索引位置上的元素不再是标量而是一维数组:


```python
arr2d = np.array([[1,2,3],[4,5,6],[7,8,9]])
arr2d[2]
```




    array([7, 8, 9])



要访问里面元素有两种方式


```python
# 方式1
arr2d[2][1]
```




    8




```python
# 方式2
arr2d[2,1]
```




    8



在更高维度的数组中同理，如：在2×2×3的arr3d中：


```python
arr3d = np.array([[[1,2,3],[4,5,6]],[[7,8,9],[10,11,12]]])
arr3d
```




    array([[[ 1,  2,  3],
            [ 4,  5,  6]],
    
           [[ 7,  8,  9],
            [10, 11, 12]]])




```python
arr3d[0]
```




    array([[1, 2, 3],
           [4, 5, 6]])



标量值和数组都可以赋值给arr3d[0]:


```python
old_values = arr3d[0].copy()
```


```python
arr3d[0] = 42
arr3d
```




    array([[[42, 42, 42],
            [42, 42, 42]],
    
           [[ 7,  8,  9],
            [10, 11, 12]]])




```python
arr3d[0] = old_values
arr3d
```




    array([[[ 1,  2,  3],
            [ 4,  5,  6]],
    
           [[ 7,  8,  9],
            [10, 11, 12]]])




```python
arr3d[0,1]
```




    array([4, 5, 6])



### 切片索引
ndarray的切片语法跟python列表这样的一维对象差不多：


```python
arr[1:6]
```




    array([ 1,  2,  3,  4, 64])



高维度对象可以在一个或多个轴上进行切片，也可以跟整数索引混合使用。如：


```python
arr2d
```




    array([[1, 2, 3],
           [4, 5, 6],
           [7, 8, 9]])




```python
arr2d[:2]
```




    array([[1, 2, 3],
           [4, 5, 6]])




```python
# 可以一次传入多个切片，就像传入多个索引那样
arr2d[:2,1:]
```




    array([[2, 3],
           [5, 6]])




```python
# 可以整数索引和切片混合
arr2d[1,:2]
```




    array([4, 5])




```python
arr2d[2,:1]
```




    array([7])




```python
# 注意，“只有冒号”表示选取整个轴
arr2d[:,:1]
```




    array([[1],
           [4],
           [7]])




```python
# 当然，对切片表达式的赋值也会被扩散到整个选区
arr2d[:2,1:]=0
arr2d
```




    array([[1, 0, 0],
           [4, 0, 0],
           [7, 8, 9]])



# 布尔型索引
假设我们有个存储数据的数组和一个存储名字的数组(含重复项)。在这里，我们使用numpy.random中的randn函数生成一些正态分布的随机数据


```python
names = np.array(['Bob','Joe','Will','Bob','Will','Joe','Joe'])
```


```python
data = np.random.randn(7,4)
data
```




    array([[-0.12137403, -0.21989713, -0.28924979, -0.93689261],
           [-0.91754465,  1.16823752, -0.38574666, -0.21475166],
           [ 0.17283649, -0.17393293,  0.93879546,  1.2980231 ],
           [ 2.9162052 , -0.15326669,  1.17628485,  0.96175703],
           [-0.86929264,  1.45663917,  0.76956501, -0.83683981],
           [ 1.21612489, -0.10835012, -1.74800688, -0.36114468],
           [ 0.07558196,  1.11354748, -1.08176614,  0.40204156]])




```python
# 假设每个名字都对应data数组中的一行，而我们想选出对应名字"Bob"的所有行
# 跟算术运算一样，数组的比较运算(==)也是矢量化的，因此可以通过比较运算得到一个布尔数组
names == 'Bob'
```




    array([ True, False, False,  True, False, False, False])




```python
# 这个布尔数组可以用于索引，当然布尔数组的长度必须与被索引的轴长度一致
data[names == 'Bob']
```




    array([[-0.12137403, -0.21989713, -0.28924979, -0.93689261],
           [ 2.9162052 , -0.15326669,  1.17628485,  0.96175703]])




```python
data[names == 'Bob',2:]   # 注意，这里和上面二位数组切片不一样，这里2:是直接在选中所有轴的情况下进行切
```




    array([[-0.28924979, -0.93689261],
           [ 1.17628485,  0.96175703]])




```python
data[names == 'Bob',3]   # 注意，这里和上面二位数组切片不一样，这里2:是直接在选中所有轴的情况下进行切
```




    array([-0.93689261,  0.96175703])



要选择除'Bob'外的其他值，既可以使用 != ，也可以通过负号 - 对条件进行否定


```python
# 使用！=
names != 'Bob'
```




    array([False,  True,  True, False,  True,  True,  True])




```python
# 方式2 使用负号  ？？？变成~了  -用了报错
data[~(names == 'Bob')]
```




    array([[-0.91754465,  1.16823752, -0.38574666, -0.21475166],
           [ 0.17283649, -0.17393293,  0.93879546,  1.2980231 ],
           [-0.86929264,  1.45663917,  0.76956501, -0.83683981],
           [ 1.21612489, -0.10835012, -1.74800688, -0.36114468],
           [ 0.07558196,  1.11354748, -1.08176614,  0.40204156]])




```python
~(names == 'Bob')
```




    array([False,  True,  True, False,  True,  True,  True])



选取这三个名字中的两个需要组合应用多个布尔条件，使用&（和），|（或）之类的布尔算术运算符即可


```python
mask = (names == 'Bob')|(names == 'Will')
mask
```




    array([ True, False,  True,  True,  True, False, False])




```python
data[mask]
```




    array([[-0.12137403, -0.21989713, -0.28924979, -0.93689261],
           [ 0.17283649, -0.17393293,  0.93879546,  1.2980231 ],
           [ 2.9162052 , -0.15326669,  1.17628485,  0.96175703],
           [-0.86929264,  1.45663917,  0.76956501, -0.83683981]])



通过布尔型索引选取数组中的数据，将总是创建数据的副本，即使返回一模一样的数组也是如此

通过布尔型数组设置值是一种常用的手段，为了将data中所有的负值都设为0，我们只需要：


```python
data[data<0]=0
data
```




    array([[0.        , 0.        , 0.        , 0.        ],
           [0.        , 1.16823752, 0.        , 0.        ],
           [0.17283649, 0.        , 0.93879546, 1.2980231 ],
           [2.9162052 , 0.        , 1.17628485, 0.96175703],
           [0.        , 1.45663917, 0.76956501, 0.        ],
           [1.21612489, 0.        , 0.        , 0.        ],
           [0.07558196, 1.11354748, 0.        , 0.40204156]])




```python
# 也可以通过一维布尔数组设置整行或整列的值
data[names != 'Joe'] = 7
data
```




    array([[7.        , 7.        , 7.        , 7.        ],
           [0.        , 1.16823752, 0.        , 0.        ],
           [7.        , 7.        , 7.        , 7.        ],
           [7.        , 7.        , 7.        , 7.        ],
           [7.        , 7.        , 7.        , 7.        ],
           [1.21612489, 0.        , 0.        , 0.        ],
           [0.07558196, 1.11354748, 0.        , 0.40204156]])



# Day 2
# 花式索引
花式索引(Fancy indexing)是一个NumPy术语，它指的是利用整数数组进行索引。假设我们有一个8×4数组：


```python
arr = np.empty((8,4))
arr
```




    array([[1.28720507e-311, 1.06224114e-321, 0.00000000e+000,
            0.00000000e+000],
           [2.37663529e-312, 5.02034658e+175, 2.25285651e+184,
            1.80260843e+185],
           [1.47791958e-075, 2.19508539e-056, 6.44357065e-067,
            7.75582049e-144],
           [3.59751658e+252, 1.46901661e+179, 8.37404147e+242,
            2.59027926e-144],
           [3.80985069e+180, 1.14428494e+243, 2.59027907e-144,
            7.79952704e-143],
           [3.42166000e-032, 1.54728069e-075, 1.44071214e+160,
            1.79075917e+160],
           [2.59027856e-144, 2.59903818e-144, 6.19410688e-091,
            3.51046162e-033],
           [2.58082100e-057, 1.11475752e+261, 1.16318408e-028,
            2.97707521e+296]])




```python
for i in range(8):
    arr[i]=i
arr
```




    array([[0., 0., 0., 0.],
           [1., 1., 1., 1.],
           [2., 2., 2., 2.],
           [3., 3., 3., 3.],
           [4., 4., 4., 4.],
           [5., 5., 5., 5.],
           [6., 6., 6., 6.],
           [7., 7., 7., 7.]])



想要以特定顺序选取行子集，只需传入一个用于指定顺序的整数列表或ndarray即可：


```python
arr[[4,3,0,6]]
```




    array([[4., 4., 4., 4.],
           [3., 3., 3., 3.],
           [0., 0., 0., 0.],
           [6., 6., 6., 6.]])



同列表一样，使用负数索引会从末尾开始选取行


```python
arr[[-3,-5,-7]]
```




    array([[5., 5., 5., 5.],
           [3., 3., 3., 3.],
           [1., 1., 1., 1.]])



有点不符预期直觉的是，一次传入多个索引数组返回的是一个以为数组，其中的元素对应各个索引元组:


```python
arr = np.arange(32).reshape((8,4))
arr
```




    array([[ 0,  1,  2,  3],
           [ 4,  5,  6,  7],
           [ 8,  9, 10, 11],
           [12, 13, 14, 15],
           [16, 17, 18, 19],
           [20, 21, 22, 23],
           [24, 25, 26, 27],
           [28, 29, 30, 31]])




```python
arr[[1,5,7,2],[0,3,1,2]]   # 即分别对应元素(1,0)......
```




    array([ 4, 23, 29, 10])



想要得到预计的结果(选出对应行对应列的矩阵)，有两种方法


```python
# 方法1
arr[[1,5,7,2]][:,[0,3,1,2]]
```




    array([[ 4,  7,  5,  6],
           [20, 23, 21, 22],
           [28, 31, 29, 30],
           [ 8, 11,  9, 10]])




```python
# 方式2   使用np.ix_函数，该函数作用是将两个一维整数数组转换为一个用于选取方形区域的索引器
arr[np.ix_([1,5,7,2],[0,3,1,2])]
```




    array([[ 4,  7,  5,  6],
           [20, 23, 21, 22],
           [28, 31, 29, 30],
           [ 8, 11,  9, 10]])



记住，花式索引跟切片不一样，它总是将数据赋值到新数组中
# 数组转置和轴对换

转置(transpose)是重塑的一种特殊形式，它返回的是源数据的视图(不会进行任何复制操作)。瘫坐不但有transpose方法，还要一个特殊的T属性:


```python
arr = np.arange(15).reshape(3,5)
arr
```




    array([[ 0,  1,  2,  3,  4],
           [ 5,  6,  7,  8,  9],
           [10, 11, 12, 13, 14]])




```python
arr.T
```




    array([[ 0,  5, 10],
           [ 1,  6, 11],
           [ 2,  7, 12],
           [ 3,  8, 13],
           [ 4,  9, 14]])



在进行矩阵计算时，经常需要用到该操作，比如利用np.dot计算矩阵内积X转置X


```python
arr = np.random.randn(6,3)
arr
```




    array([[-0.37837149,  0.06849045, -0.74938424],
           [ 0.65189709,  0.38934392,  0.71622347],
           [-0.6334776 , -1.3998728 , -1.46899174],
           [-1.7952196 ,  0.25083811, -0.48422619],
           [ 0.17942745, -0.27613012,  0.12383641],
           [ 0.23774314, -0.04360816,  2.4257589 ]])




```python
np.dot(arr.T,arr)
```




    array([[4.28095808, 0.60446304, 3.14924252],
           [0.60446304, 2.25699276, 2.02249294],
           [3.14924252, 2.02249294, 9.36660623]])



对于高维数组，transpose需要得到一个由轴编号组成的元组才能对这些轴进行转置(0,1,2)->(1,0,2)


```python
arr = np.arange(16).reshape((2,2,4))
arr
```




    array([[[ 0,  1,  2,  3],
            [ 4,  5,  6,  7]],
    
           [[ 8,  9, 10, 11],
            [12, 13, 14, 15]]])




```python
arr.transpose((1,0,2))
```




    array([[[ 0,  1,  2,  3],
            [ 8,  9, 10, 11]],
    
           [[ 4,  5,  6,  7],
            [12, 13, 14, 15]]])




```python
arr  # 迷惑，书上写transpose返回的是源数据的视图而非复制品，但为什么这里源程序没变
```




    array([[[ 0,  1,  2,  3],
            [ 4,  5,  6,  7]],
    
           [[ 8,  9, 10, 11],
            [12, 13, 14, 15]]])



对于上面的疑惑的解答:视图不等于原来的就也会变，只不过它也指向源数据，在它里面修改后源数据也会跟着变。即不会进行任何复制操作的意思！
简单的转置可以使用.T,它其实就是进行轴对换而已，ndarray还有一个swapaxes方法，他需要接受一对轴编号


```python
arr.swapaxes(1,2)# 其实就是弱化版transpose ，括号里输入的是要交换的一堆轴号
```




    array([[[ 0,  4],
            [ 1,  5],
            [ 2,  6],
            [ 3,  7]],
    
           [[ 8, 12],
            [ 9, 13],
            [10, 14],
            [11, 15]]])



同上，这里返回的是源数据的视图，但不会进行复制操作！即arr还是原来那样

# 2.通用函数：快速的元素级数组函数
通用函数(即ufunc)是一种对ndarray中的数据执行元素级运算的函数。可以将其看做简单函数(接受一个或多个标量值，并产生一个或多个标量值)
的矢量化包装器
许多ufunc都是简单的元素级变体,如sqrt和exp:


```python
arr = np.arange(10)
np.sqrt(arr)
```




    array([0.        , 1.        , 1.41421356, 1.73205081, 2.        ,
           2.23606798, 2.44948974, 2.64575131, 2.82842712, 3.        ])




```python
np.exp(arr)
```




    array([1.00000000e+00, 2.71828183e+00, 7.38905610e+00, 2.00855369e+01,
           5.45981500e+01, 1.48413159e+02, 4.03428793e+02, 1.09663316e+03,
           2.98095799e+03, 8.10308393e+03])



以上是一元ufunc，另外一些(如add和maximum)接受2个数组(因此也叫二元(binary)ufunc)，并返回一个结果数组:


```python
x = np.random.randn(8)
x
```




    array([ 0.94665965, -0.4754774 , -0.15001702, -1.49266338, -1.43456233,
           -0.59047708,  0.6526553 , -2.49389592])




```python
y = np.random.randn(8)
y
```




    array([-0.0863673 ,  0.1911106 ,  0.53903421, -1.00703208, -1.20888113,
            0.12637546, -0.14495472,  1.93305098])




```python
np.maximum(x,y)
```




    array([ 0.94665965,  0.1911106 ,  0.53903421, -1.00703208, -1.20888113,
            0.12637546,  0.6526553 ,  1.93305098])



也有一些不常见的ufunc可以返回多个数组，如modf可以返回浮点数数组的小数和整数部分


```python
arr = np.random.randn(7)*5
arr
```




    array([11.14458519,  1.0766965 ,  1.19843104,  2.51754491,  5.51744021,
           -4.93376601,  4.1171672 ])




```python
np.modf(arr)
```




    (array([ 0.14458519,  0.0766965 ,  0.19843104,  0.51754491,  0.51744021,
            -0.93376601,  0.1171672 ]),
     array([11.,  1.,  1.,  2.,  5., -4.,  4.]))



还有一些一元和二元ufunc可以查表

# 3.利用数组进行数据分析
Numpy数组可以将许多数据处理任务表述为简洁的数组表达式
假设我们想在一组值(网格型)上计算函数sqrt(x方+y方)。np.meshgrid函数接受两个一维数组，并产生两个二维矩阵(对应于两个数组中所有的(x,y)对)


```python
points = np.arange(-5,5,0.01) # 1000个间隔相等的点
```


```python
xs,ys = np.meshgrid(points,points)
xs
```




    array([[-5.  , -4.99, -4.98, ...,  4.97,  4.98,  4.99],
           [-5.  , -4.99, -4.98, ...,  4.97,  4.98,  4.99],
           [-5.  , -4.99, -4.98, ...,  4.97,  4.98,  4.99],
           ...,
           [-5.  , -4.99, -4.98, ...,  4.97,  4.98,  4.99],
           [-5.  , -4.99, -4.98, ...,  4.97,  4.98,  4.99],
           [-5.  , -4.99, -4.98, ...,  4.97,  4.98,  4.99]])




```python
ys
```




    array([[-5.  , -5.  , -5.  , ..., -5.  , -5.  , -5.  ],
           [-4.99, -4.99, -4.99, ..., -4.99, -4.99, -4.99],
           [-4.98, -4.98, -4.98, ..., -4.98, -4.98, -4.98],
           ...,
           [ 4.97,  4.97,  4.97, ...,  4.97,  4.97,  4.97],
           [ 4.98,  4.98,  4.98, ...,  4.98,  4.98,  4.98],
           [ 4.99,  4.99,  4.99, ...,  4.99,  4.99,  4.99]])




```python
np.meshgrid(points,points)  # meshgrid返回的是传入的两种一维数组的所有组合值,对应位置的x，y即一对组合
```




    [array([[-5.  , -4.99, -4.98, ...,  4.97,  4.98,  4.99],
            [-5.  , -4.99, -4.98, ...,  4.97,  4.98,  4.99],
            [-5.  , -4.99, -4.98, ...,  4.97,  4.98,  4.99],
            ...,
            [-5.  , -4.99, -4.98, ...,  4.97,  4.98,  4.99],
            [-5.  , -4.99, -4.98, ...,  4.97,  4.98,  4.99],
            [-5.  , -4.99, -4.98, ...,  4.97,  4.98,  4.99]]),
     array([[-5.  , -5.  , -5.  , ..., -5.  , -5.  , -5.  ],
            [-4.99, -4.99, -4.99, ..., -4.99, -4.99, -4.99],
            [-4.98, -4.98, -4.98, ..., -4.98, -4.98, -4.98],
            ...,
            [ 4.97,  4.97,  4.97, ...,  4.97,  4.97,  4.97],
            [ 4.98,  4.98,  4.98, ...,  4.98,  4.98,  4.98],
            [ 4.99,  4.99,  4.99, ...,  4.99,  4.99,  4.99]])]



现在，对该函数的求值运算只要把这两个数组当作两个[浮点数]编写表达式即可


```python
import matplotlib.pyplot as plt
```


```python
z = np.sqrt(xs**2+ys**2)
z
```




    array([[7.07106781, 7.06400028, 7.05693985, ..., 7.04988652, 7.05693985,
            7.06400028],
           [7.06400028, 7.05692568, 7.04985815, ..., 7.04279774, 7.04985815,
            7.05692568],
           [7.05693985, 7.04985815, 7.04278354, ..., 7.03571603, 7.04278354,
            7.04985815],
           ...,
           [7.04988652, 7.04279774, 7.03571603, ..., 7.0286414 , 7.03571603,
            7.04279774],
           [7.05693985, 7.04985815, 7.04278354, ..., 7.03571603, 7.04278354,
            7.04985815],
           [7.06400028, 7.05692568, 7.04985815, ..., 7.04279774, 7.04985815,
            7.05692568]])




```python
plt.imshow(z,cmap=plt.cm.gray);plt.colorbar()
plt.title("Image plot of $\sqrt{x^2+y^2}$ for a grid of values")
```




    Text(0.5, 1.0, 'Image plot of $\\sqrt{x^2+y^2}$ for a grid of values')




    
![png](output_140_1.png)
    


# 将条件逻辑表述为数组运算
numpy.where函数是三元表达式 x if condition else y 的矢量化版本，假设我们有一个布尔数组和两个值数组:


```python
xarr = np.array([1.1,1.2,1.3,1.4,1.5])
yarr = np.array([2.1,2.2,2.3,2.4,2.5])
cond = np.array([True,False,True,True,False])
```

假设我们想要根据cond中的值选中xarr和yarr的值:当cond中的值为True时，选取xarr的值，否则从yarr中选取。列表推导式写法如下


```python
result = [(x if c else y) for x,y,c in zip(xarr,yarr,cond)] # zip()将迭代对象作为参数，将对象中对应方法打包成一个元组，然后返回
result                                                       # 由这些元组组成的list
```




    [1.1, 2.2, 1.3, 1.4, 2.5]



这种纯python的写法处理速度慢，且无法用于多维数组，若用np.where就可以把功能写的很简洁


```python
result = np.where(cond,xarr,yarr)
result
```




    array([1.1, 2.2, 1.3, 1.4, 2.5])



np.where的第一个参数为判断条件，而第二第三参数不必是数组，可以是标量值。
在使用中np.where经常用于根据一个数组产生一个新的数组：
假设有一个由随机数据组成的矩阵，将所有正值替换为2，所有负值替换成-2


```python
arr = np.random.randn(4,4)
arr
```




    array([[ 1.39595466, -0.06786897, -0.38880612,  0.65788331],
           [ 0.45516478, -0.02129167, -1.13867192, -1.27983256],
           [-0.90151097,  1.33607766, -0.46125103, -0.51132908],
           [ 0.45729048, -0.6141165 , -0.80421038, -1.60341814]])




```python
np.where(arr>0,2,-2)
```




    array([[ 2, -2, -2,  2],
           [ 2, -2, -2, -2],
           [-2,  2, -2, -2],
           [ 2, -2, -2, -2]])




```python
arr # 原来的不变
```




    array([[ 1.39595466, -0.06786897, -0.38880612,  0.65788331],
           [ 0.45516478, -0.02129167, -1.13867192, -1.27983256],
           [-0.90151097,  1.33607766, -0.46125103, -0.51132908],
           [ 0.45729048, -0.6141165 , -0.80421038, -1.60341814]])




```python
# 也可以只把正值设置为2，其余不变
np.where(arr>0,2,arr)
```




    array([[ 2.        , -0.06786897, -0.38880612,  2.        ],
           [ 2.        , -0.02129167, -1.13867192, -1.27983256],
           [-0.90151097,  2.        , -0.46125103, -0.51132908],
           [ 2.        , -0.6141165 , -0.80421038, -1.60341814]])



传递给where的数据大小可以不相等，甚至可以是标量值。
使用where可以表达出更复杂的逻辑，比如我们有两个布尔型数组cond1和cond2

### 逻辑
result = []
for i in range(n):
    if cond1[i] and cond2[i]:
        result.append(0)
    elif cond1[i]:
        result.append(1)
    elif cond2[i]:
        result.append(2)
    else:
        result.append(3)
这个for循环可以改写成一个嵌套的where表达式:

np.where(cond1 & cond2,0,
        np.where(cond1,1,
                np.where(cond2,2,3)))

我们还可以用"布尔值在计算过程中可以被当作0或1处理"改写成一下算术运算（6）

result = 1*(cond1 - cond2) + 2*(cond2 & -cond1) + 3* -(cond1|cond2)

# 数学和统计方法
可以通过数组上的一组数学函数对整个数组或某个轴向的数据进行统计计算。sum、mean以及标准差std等聚合计算(直接得到最终结果，aggregation，通常叫做约简(reduction))既可以当作数组的实例方法使用，也可以当作顶级Numpy函数使用


```python
arr = np.random.randn(5,4)# 正态分布数据
arr
```




    array([[ 0.68920602, -0.53510218,  1.1939524 , -1.43757147],
           [-0.52695821, -0.02314714,  0.25601309, -0.53765451],
           [-1.06257951, -2.08250046,  0.14740113, -1.0689935 ],
           [ 0.78087519, -0.02727014,  0.85753957,  0.02663162],
           [ 1.16680306, -0.58284562,  1.02442472, -0.71781284]])




```python
arr.mean() # 数组实例方法
```




    -0.12297943940984805




```python
np.mean(arr)  # numpy函数
```




    -0.12297943940984805




```python
arr.sum()
```




    -2.459588788196961



mena和sum这类函数可以接受一个axis参数(用于计算该轴上的统计值)，最终结果是一个少一维的数组:
axis = 0时表示按列，=1时表示按行(原理即把每个数字的元组组成写出来(0,1)，对照第几列就是轴几)


```python
arr.mean(axis = 1) # 按行
```




    array([-0.02237881, -0.20793669, -1.01666809,  0.40944406,  0.22264233])




```python
arr.sum(0) # 按列
```




    array([ 1.04734655, -3.25086553,  3.47933091, -3.73540071])



其他如cumsum和cumprod之类的方法不聚合，而是产生一个由中间结果组成的数组:


```python
arr = np.array([[0,1,2],[3,4,5],[6,7,8]])
arr
```




    array([[0, 1, 2],
           [3, 4, 5],
           [6, 7, 8]])




```python
arr.cumsum()
```




    array([ 0,  1,  3,  6, 10, 15, 21, 28, 36])




```python
arr.cumsum(0)
```




    array([[ 0,  1,  2],
           [ 3,  5,  7],
           [ 9, 12, 15]])




```python
arr.cumprod(1)
```




    array([[  0,   0,   0],
           [  3,  12,  60],
           [  6,  42, 336]])




```python
arr.prod(1)
```




    array([  0,  60, 336])



还有一些数组统计方法见p104表
# 用于布尔型数组的方法
在上述这些方法中，布尔值会被强制转换为1，(True)和0(False)。因此，sum经常被用来对布尔型数组中的True值计数:


```python
arr = np.random.randn(100)
(arr>0).sum()
```




    51



还有两个方法any和all，他们对布尔型数组非常有用，当然也可以用于非布尔型数组，所有非0元素将被当作True。
any用于检测数组中是否存在一个或多个True，而all则检查数组中所有值是否都是True


```python
bools = np.array([False,False,True,False])
```


```python
bools.any()
```




    True




```python
bools.all()
```




    False



# 排序
跟python内置的列表一样，NumPy数组也可以通过sort方法排序:


```python
arr = np.random.randn(8)
arr
```




    array([ 0.78360551,  0.33184397,  0.72934639, -1.08776835, -0.09152173,
           -0.41032779, -0.37258074, -0.06877516])




```python
arr.sort()
arr
```




    array([-1.08776835, -0.41032779, -0.37258074, -0.09152173, -0.06877516,
            0.33184397,  0.72934639,  0.78360551])



多维数组可以在任何一个轴上进行排序，只需将轴编号传给sort即可(原理即把每个数字的元组组成写出来如(0,1,2)，对照第几列就是轴几)
比如说
0.58(0,1)
1.14(0,2)
-0.41(0,3)
由于轴线是1，就是对着取元组右半边排序，从效果上来看就是按行排序


```python
arr = np.random.randn(5,3)
arr
```




    array([[ 0.5888034 ,  1.14279987, -0.41475084],
           [-0.52047509, -1.61858872,  1.36510202],
           [ 0.03819903, -0.60642371,  0.87989419],
           [ 1.03046213,  1.30044014,  2.24327605],
           [-0.19006715,  0.0345155 , -0.30115184]])




```python
arr.sort(1)
arr
```




    array([[-0.41475084,  0.5888034 ,  1.14279987],
           [-1.61858872, -0.52047509,  1.36510202],
           [-0.60642371,  0.03819903,  0.87989419],
           [ 1.03046213,  1.30044014,  2.24327605],
           [-0.30115184, -0.19006715,  0.0345155 ]])



顶级方法np.sort返回的是数组的已排序副本，而就地排序则会修改数组本身。计算数组分位数最简单的办法是对其进行排序，然后选取特定位置的值:


```python
large_arr = np.random.randn(1000)
large_arr.sort()
```


```python
large_arr[int(0.05*len(large_arr))]    # 5%分位数
```




    -1.6702712860098508




```python
large_arr[int(0.5*len(large_arr))]
```




    0.04077811570603626



更多关于numpy排序方法以及注入间接排序之类的高级技术在第12章，在pandas中还可以找到一些其他跟排序有关的数据操作(比如根据一列或多列对表格型数据进行排序)

# 唯一化以及其他的集合逻辑
numpy提供了一些针对一维数组ndarray的基本集合运算。最常用的是np.unique，它用于找出数组中的唯一值并返回已排序的结果:


```python
# 例1
names = np.array(['Bob','Joe','Will','Bob','Will','Joe','Joe'])
np.unique(names)
```




    array(['Bob', 'Joe', 'Will'], dtype='<U4')




```python
names
```




    array(['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe'], dtype='<U4')




```python
# 例2   注意返回的是已排好序的结果
ints = np.array([3,3,3,2,2,1,1,4,4])
np.unique(ints)
```




    array([1, 2, 3, 4])




```python
# python纯代码实现
sorted(set(names))        # set集合具有去重效果，然后再排序
```




    ['Bob', 'Joe', 'Will']



另一个函数比较常用的函数是np.in1d(x,y)，得到一个"x的元素是否包含于y"的布尔型数组


```python
values = np.array([6,0,0,3,2,5,6])
```


```python
np.in1d(values,[2,3,6])
```




    array([ True, False, False,  True,  True, False,  True])



还有一些集合函数见p107

# 4.用于数组的文件输入输出
NumPy能够读写磁盘上的文本数据或二进制数据。后面会介绍一些pandas中用于将表格型数据读取到内存的工具。

# 将数组以二进制格式保存到磁盘
np.save和np.load是读写磁盘数组数据的两个主要函数。默认情况下，数组是以未压缩的原始二进制格式保存在扩展名为.npy的文件中


```python
arr = np.arange(10)
```


```python
np.save('some_array',arr)# 默认存在jupyer打开的路径里
```

如果文件路径末尾没有扩展名.npy，则该扩展名会被自动加上。然后就可以通过np.load读取磁盘上的数组。


```python
np.load('some_array.npy')
```




    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])



通过np.savez可以将多个数组保存到一个压缩文件中，将数组以关键字参数的形式传入即可


```python
np.savez('array_archive.npz',a=arr,b=arr)
```

加载.npz文件时，可以得到一个类似字典的对象，该对象会对各个数组进行延迟加载


```python
arch = np.load('array_archive.npz')
```


```python
arch['b']  # 类似于字典
```




    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])



# 存取文本文件
从文件中加载文本是一件非常标准的任务，python的文件读写函数的格式容易晕，所有主要使用pandas中的read_csv和read_table。
有时需要用np.loadtxt或更为专门化的np.genfromtxt将数据加载到普通的numpy数组中。
这些函数都有很多想选可供使用：指定各种分隔符、针对特定列的转换器函数、需要跳过的行数等。以一个简单的逗号分隔文件(csv)为例

'E:\data_analysis\资料\pydata-book-3rd-edition\examples/array_ex.txt'
将上地址的文件加载到一个二维数组中：


```python
arr = np.loadtxt('E:/data_analysis/资料/pydata-book-3rd-edition/examples/array_ex.txt',delimiter=',')  # 以逗号分隔文件(CSV)
```


```python
arr
```




    array([[ 0.580052,  0.18673 ,  1.040717,  1.134411],
           [ 0.194163, -0.636917, -0.938659,  0.124094],
           [-0.12641 ,  0.268607, -0.695724,  0.047428],
           [-1.484413,  0.004176, -0.744203,  0.005487],
           [ 2.302869,  0.200131,  1.670238, -1.88109 ],
           [-0.19323 ,  1.047233,  0.482803,  0.960334]])



np.savetxt执行的是相反的操作：将数组写到以某种分隔符隔开的文本文件中。
genfromtxt跟loadtxt差不多，只不过它面向的是结构化数组和缺失数据处理。更多相关结构化数组知识看第12章
更多有关文件读写(尤其是表格型数据)知识名字后面pandas和DataFrame对象章节

# 5.线性代数
线性代数(如矩阵乘法、矩阵分解、行列式以及其他方阵数学等)是任何数组库的重要组成部分。以为通过 * 对两个二维数组相乘得到的是一个元素级的积，而不是一个矩阵点积。因此，numpy提供了一个用于矩阵乘法的dot函数(即是一个数组方法也是numpy命名空间中的一个函数)


```python
x = np.array([[1.,2.,3.],[4.,5.,6.]])
x
```




    array([[1., 2., 3.],
           [4., 5., 6.]])




```python
y = np.array([[6.,23.],[-1,7],[8,9]])
y
```




    array([[ 6., 23.],
           [-1.,  7.],
           [ 8.,  9.]])




```python
x.dot(y)   # 相当于np.dot(x,y)
```




    array([[ 28.,  64.],
           [ 67., 181.]])



一个二位数组跟一个大小合适的以为数组的矩阵点积运算之后得到的是一个一维数组


```python
np.dot(x,np.ones(3))
```




    array([ 6., 15.])



numpy.linalg中有一组标准的矩阵分解运算以及诸如 求逆 和 行列式 之类的东西


```python
from numpy.linalg import inv,qr  # inv求逆，qr用于QR分解
```


```python
X = np.random.randn(5,5)
X
```




    array([[ 2.89286303, -0.65673005,  0.66105493,  0.90273529, -0.74807308],
           [-0.92062622,  0.04199541,  0.10603415,  0.83816582, -0.17104726],
           [-0.1928912 ,  1.00254358,  0.81995827,  0.83242996, -0.77163792],
           [ 0.20182507, -1.02403026, -0.53053515, -0.00724483, -1.01890923],
           [-0.37888763,  0.43815606,  1.15563841, -0.32768204,  1.11999838]])




```python
mat = X.T.dot(X)
mat
```




    array([[ 9.43770533, -2.50456087,  1.11162841,  1.8019762 , -2.48775515],
           [-2.50456087,  2.67877031,  1.44199623,  0.1407361 ,  1.24462618],
           [ 1.11162841,  1.44199623,  2.7375361 ,  0.99335133,  0.68951517],
           [ 1.8019762 ,  0.1407361 ,  0.99335133,  2.3178206 , -1.820634  ],
           [-2.48775515,  1.24462618,  0.68951517, -1.820634  ,  3.47686799]])




```python
inv(mat)
```




    array([[ 0.29689758,  0.40996611, -0.3954729 ,  0.04581219,  0.16809546],
           [ 0.40996611,  1.17580697, -0.74434218, -0.09406032, -0.02920992],
           [-0.3954729 , -0.74434218,  1.38719519, -0.7999547 , -0.71050406],
           [ 0.04581219, -0.09406032, -0.7999547 ,  1.56481962,  1.04449871],
           [ 0.16809546, -0.02920992, -0.71050406,  1.04449871,  1.10619355]])




```python
mat.dot(inv(mat))   #AA逆=E
```




    array([[ 1.00000000e+00, -8.43770576e-17, -2.21732134e-16,
            -8.72072324e-17,  5.03091062e-17],
           [ 2.57269986e-17,  1.00000000e+00,  1.57772094e-16,
             4.48459175e-17, -1.01227168e-16],
           [ 4.69994023e-17,  2.69934857e-16,  1.00000000e+00,
            -2.66611985e-16,  1.43496216e-16],
           [-2.59928616e-18,  9.24664952e-17, -5.59677972e-17,
             1.00000000e+00, -1.06848902e-16],
           [-4.46024702e-17,  2.36684481e-16, -1.77451021e-16,
            -4.10613245e-16,  1.00000000e+00]])




```python
q,r = qr(mat)
```


```python
q # 正交矩阵Q
```




    array([[-0.91660669, -0.11085139,  0.15628852,  0.33645005,  0.0995962 ],
           [ 0.2432474 , -0.6970772 ,  0.66142261,  0.13089951, -0.01730681],
           [-0.10796332, -0.63959508, -0.62785024, -0.08859236, -0.42097213],
           [-0.17501113, -0.24441848, -0.03357167, -0.72492203,  0.61886324],
           [ 0.2416152 , -0.18158491, -0.37785057,  0.57991907,  0.6554173 ]])




```python
r # 上三角矩阵R
```




    array([[-10.2963522 ,   3.06770867,  -0.97096791,  -2.5702525 ,
              3.66729809],
           [  0.        ,  -2.7723732 ,  -3.24732185,  -1.16911664,
             -1.21919011],
           [  0.        ,   0.        ,  -0.88514119,   0.36115285,
             -1.25111077],
           [  0.        ,   0.        ,   0.        ,  -2.19936564,
              2.60094957],
           [  0.        ,   0.        ,   0.        ,   0.        ,
              0.59249785]])



常用numpy.linalg函数见p110

# 6.随机数生成
numpy.random对python内置的random进行了补充,增加了一些用于高效生成多种概率分布的样本值的函数。例如，你可以用normal来得到一个标准正态分布的4×4样本数组


```python
samples = np.random.normal(size=(4,4))
samples
```




    array([[ 7.98615231e-01, -4.87054898e-01, -7.03793088e-01,
            -4.13481389e-01],
           [-1.20188500e-03, -5.94326808e-01, -7.49469336e-01,
            -5.46399378e-02],
           [-3.58513700e-05, -2.31094158e+00, -5.56742217e-01,
            -1.15091429e+00],
           [ 1.70448563e+00,  8.07285798e-02,  8.12735969e-01,
             5.77782646e-01]])



pyhton内置的random模块只能一次生成一个样本值。如果需要大量样本值，numpy.random快了不止一个数量级


```python
from random import normalvariate  #python内置模块
```


```python
N=1000000
```


```python
%timeit samples = [normalvariate(0,1) for _ in range(N)]
```

    786 ms ± 28.5 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
    


```python
%timeit np.random.normal(size=N)
```

    23.9 ms ± 300 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)
    

部分numpy.random函数可见p111

# 7.范例：随机漫步
通过模拟随机漫步说明如何运用数组运算。先看一个简单的随机漫步的例子:从0开始，步长1和-1出现的概率相等。我们通过内置的random模块以纯python方式实现1000步的随机漫步：


```python
# 纯python
import random
position = 0
walk = [position]
steps = 1000
for i in range(steps):
    step = 1 if random.randint(0,1) else -1   # randint(0,1)表示取范围内的整数，边界也算，所以就是0和1
    position += step
    walk.append(position)
position
```




    -4



不难看出随机漫步就是将各步的累计和，可以用一个数组运算来实现。因此，我用np.random模块一次性随机产生1000个"抛硬币"结果(即两个数中选一个)
然后将其分别设置为1或-1，然后计算累计和:


```python
nsteps = 1000
```


```python
draws = np.random.randint(0,2,size=nsteps)  # 利用np内置的random取随机数，左闭右开所以只有0和1
draws
```




    array([1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0,
           1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1,
           0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0,
           1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1,
           0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0,
           1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0,
           1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1,
           0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1,
           0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0,
           0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0,
           1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0,
           1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0,
           1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0,
           0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0,
           1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1,
           1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1,
           1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1,
           1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0,
           0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1,
           0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1,
           1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1,
           0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0,
           0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1,
           1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0,
           1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0,
           0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0,
           0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1,
           0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1,
           0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1,
           1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0,
           1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0,
           1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0,
           0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1,
           0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0,
           1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0,
           0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0,
           1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1,
           0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1,
           0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0,
           0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0,
           1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1,
           1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0,
           1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0,
           0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1,
           0, 0, 0, 1, 1, 1, 0, 1, 1, 1])




```python
steps = np.where(draws>0,1,-1) # 利用where将随机数分配  诶为什么不一步到位用np.random.randint(-1,1)，噢不行中间有个0
steps
```




    array([ 1, -1, -1, -1, -1, -1, -1,  1,  1,  1,  1, -1,  1, -1, -1,  1,  1,
           -1,  1, -1, -1, -1,  1, -1,  1,  1,  1,  1,  1, -1, -1, -1,  1, -1,
           -1, -1, -1, -1,  1,  1, -1, -1, -1,  1, -1,  1,  1, -1,  1, -1,  1,
           -1,  1,  1,  1, -1,  1,  1,  1, -1,  1,  1, -1,  1,  1, -1,  1,  1,
           -1,  1, -1,  1,  1,  1, -1, -1, -1,  1, -1, -1, -1,  1, -1, -1,  1,
            1,  1,  1, -1,  1,  1, -1, -1, -1, -1,  1,  1, -1,  1, -1, -1,  1,
           -1, -1,  1,  1, -1, -1,  1, -1,  1,  1,  1,  1,  1, -1,  1, -1,  1,
            1, -1, -1,  1, -1,  1, -1, -1,  1,  1, -1, -1, -1,  1, -1, -1,  1,
           -1, -1,  1,  1,  1,  1,  1,  1, -1,  1,  1,  1, -1, -1, -1, -1, -1,
            1, -1, -1, -1,  1, -1, -1, -1,  1,  1, -1,  1,  1,  1,  1, -1,  1,
            1, -1, -1,  1, -1,  1, -1,  1,  1,  1,  1, -1, -1,  1, -1,  1,  1,
           -1, -1,  1, -1,  1,  1, -1, -1,  1, -1, -1, -1,  1, -1,  1, -1, -1,
            1, -1,  1, -1, -1,  1,  1,  1,  1, -1, -1,  1,  1,  1, -1, -1,  1,
            1, -1,  1, -1,  1, -1, -1, -1,  1,  1,  1, -1, -1, -1, -1, -1,  1,
           -1, -1,  1, -1,  1,  1, -1,  1, -1, -1, -1, -1, -1,  1, -1, -1, -1,
           -1,  1, -1, -1,  1,  1,  1,  1, -1,  1,  1, -1, -1,  1, -1,  1,  1,
            1,  1, -1,  1, -1,  1, -1,  1,  1,  1, -1, -1, -1, -1, -1,  1,  1,
            1,  1,  1,  1,  1, -1, -1,  1,  1, -1, -1,  1,  1,  1, -1,  1, -1,
            1, -1,  1, -1,  1,  1,  1,  1, -1, -1,  1, -1,  1, -1,  1,  1, -1,
           -1,  1,  1, -1, -1, -1,  1,  1, -1, -1,  1,  1, -1,  1,  1, -1, -1,
           -1, -1,  1,  1, -1, -1, -1,  1, -1,  1, -1,  1,  1, -1, -1,  1, -1,
           -1,  1, -1,  1,  1, -1, -1,  1, -1, -1, -1,  1,  1, -1, -1, -1,  1,
            1,  1,  1, -1,  1,  1,  1,  1,  1,  1, -1,  1,  1, -1,  1, -1, -1,
            1, -1, -1, -1, -1, -1, -1,  1, -1, -1, -1, -1, -1,  1, -1,  1,  1,
           -1, -1,  1, -1,  1, -1, -1,  1,  1,  1, -1,  1, -1, -1,  1,  1, -1,
            1,  1,  1,  1, -1, -1,  1,  1,  1, -1,  1,  1, -1,  1,  1,  1, -1,
           -1, -1,  1, -1,  1, -1, -1,  1, -1, -1, -1,  1, -1, -1, -1, -1,  1,
           -1, -1,  1, -1, -1, -1,  1,  1,  1,  1, -1,  1, -1,  1, -1,  1, -1,
           -1, -1,  1, -1, -1,  1,  1, -1, -1,  1, -1, -1, -1, -1, -1, -1, -1,
           -1, -1,  1,  1,  1, -1, -1, -1,  1,  1,  1,  1,  1,  1, -1, -1, -1,
            1,  1, -1,  1,  1, -1,  1, -1, -1, -1, -1, -1,  1,  1, -1, -1,  1,
           -1,  1,  1,  1, -1,  1, -1, -1, -1, -1,  1,  1,  1,  1,  1,  1, -1,
           -1,  1,  1,  1, -1, -1, -1,  1, -1, -1, -1, -1, -1,  1, -1, -1,  1,
           -1,  1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  1,  1, -1,  1,
           -1, -1,  1,  1, -1,  1, -1, -1, -1, -1, -1, -1,  1, -1,  1, -1, -1,
           -1,  1,  1,  1, -1,  1,  1,  1, -1, -1,  1, -1,  1, -1, -1,  1,  1,
            1,  1, -1,  1, -1,  1,  1, -1, -1,  1,  1, -1, -1,  1, -1,  1,  1,
           -1,  1, -1,  1, -1,  1,  1, -1,  1, -1,  1, -1,  1,  1,  1,  1,  1,
           -1,  1, -1,  1,  1, -1,  1,  1, -1, -1, -1,  1,  1,  1,  1,  1, -1,
           -1,  1, -1, -1, -1, -1,  1, -1, -1,  1,  1, -1,  1, -1, -1, -1,  1,
           -1, -1,  1,  1,  1,  1, -1, -1,  1, -1, -1, -1,  1,  1, -1,  1, -1,
           -1, -1,  1, -1, -1,  1, -1,  1, -1, -1,  1, -1, -1,  1, -1,  1,  1,
           -1,  1,  1,  1,  1,  1, -1,  1, -1,  1,  1, -1, -1,  1, -1, -1, -1,
           -1, -1, -1,  1,  1, -1,  1,  1, -1,  1, -1, -1,  1,  1,  1,  1,  1,
           -1,  1, -1,  1,  1,  1,  1, -1, -1, -1, -1, -1, -1, -1,  1,  1,  1,
            1,  1,  1,  1, -1,  1,  1, -1,  1, -1,  1,  1,  1, -1,  1,  1,  1,
            1, -1, -1,  1, -1,  1,  1,  1, -1, -1, -1, -1, -1,  1,  1, -1,  1,
            1,  1, -1,  1,  1, -1,  1, -1,  1, -1, -1,  1, -1, -1, -1,  1,  1,
            1, -1,  1, -1, -1,  1, -1,  1,  1, -1, -1,  1,  1, -1, -1,  1,  1,
            1,  1,  1, -1,  1, -1,  1,  1,  1, -1, -1,  1, -1, -1,  1,  1,  1,
           -1,  1, -1, -1,  1, -1, -1,  1, -1, -1, -1, -1,  1,  1,  1,  1,  1,
           -1,  1,  1,  1,  1, -1, -1,  1, -1,  1,  1,  1, -1, -1, -1, -1,  1,
            1,  1, -1,  1,  1, -1, -1,  1,  1, -1, -1,  1,  1,  1,  1,  1, -1,
           -1,  1, -1,  1, -1, -1, -1,  1,  1,  1, -1, -1, -1,  1,  1,  1,  1,
            1, -1, -1,  1,  1,  1,  1,  1,  1,  1,  1, -1,  1,  1, -1,  1,  1,
            1, -1, -1,  1, -1, -1, -1,  1,  1, -1, -1,  1,  1, -1, -1, -1, -1,
           -1, -1,  1, -1,  1, -1, -1,  1, -1,  1, -1,  1,  1, -1,  1, -1, -1,
            1, -1,  1,  1, -1,  1, -1, -1, -1,  1,  1,  1,  1,  1,  1, -1,  1,
            1,  1, -1,  1, -1, -1, -1,  1,  1,  1, -1,  1,  1,  1])




```python
walk = steps.cumsum()# 然后利用累加展现每一步到的坐标点
walk
```




    array([  1,   0,  -1,  -2,  -3,  -4,  -5,  -4,  -3,  -2,  -1,  -2,  -1,
            -2,  -3,  -2,  -1,  -2,  -1,  -2,  -3,  -4,  -3,  -4,  -3,  -2,
            -1,   0,   1,   0,  -1,  -2,  -1,  -2,  -3,  -4,  -5,  -6,  -5,
            -4,  -5,  -6,  -7,  -6,  -7,  -6,  -5,  -6,  -5,  -6,  -5,  -6,
            -5,  -4,  -3,  -4,  -3,  -2,  -1,  -2,  -1,   0,  -1,   0,   1,
             0,   1,   2,   1,   2,   1,   2,   3,   4,   3,   2,   1,   2,
             1,   0,  -1,   0,  -1,  -2,  -1,   0,   1,   2,   1,   2,   3,
             2,   1,   0,  -1,   0,   1,   0,   1,   0,  -1,   0,  -1,  -2,
            -1,   0,  -1,  -2,  -1,  -2,  -1,   0,   1,   2,   3,   2,   3,
             2,   3,   4,   3,   2,   3,   2,   3,   2,   1,   2,   3,   2,
             1,   0,   1,   0,  -1,   0,  -1,  -2,  -1,   0,   1,   2,   3,
             4,   3,   4,   5,   6,   5,   4,   3,   2,   1,   2,   1,   0,
            -1,   0,  -1,  -2,  -3,  -2,  -1,  -2,  -1,   0,   1,   2,   1,
             2,   3,   2,   1,   2,   1,   2,   1,   2,   3,   4,   5,   4,
             3,   4,   3,   4,   5,   4,   3,   4,   3,   4,   5,   4,   3,
             4,   3,   2,   1,   2,   1,   2,   1,   0,   1,   0,   1,   0,
            -1,   0,   1,   2,   3,   2,   1,   2,   3,   4,   3,   2,   3,
             4,   3,   4,   3,   4,   3,   2,   1,   2,   3,   4,   3,   2,
             1,   0,  -1,   0,  -1,  -2,  -1,  -2,  -1,   0,  -1,   0,  -1,
            -2,  -3,  -4,  -5,  -4,  -5,  -6,  -7,  -8,  -7,  -8,  -9,  -8,
            -7,  -6,  -5,  -6,  -5,  -4,  -5,  -6,  -5,  -6,  -5,  -4,  -3,
            -2,  -3,  -2,  -3,  -2,  -3,  -2,  -1,   0,  -1,  -2,  -3,  -4,
            -5,  -4,  -3,  -2,  -1,   0,   1,   2,   1,   0,   1,   2,   1,
             0,   1,   2,   3,   2,   3,   2,   3,   2,   3,   2,   3,   4,
             5,   6,   5,   4,   5,   4,   5,   4,   5,   6,   5,   4,   5,
             6,   5,   4,   3,   4,   5,   4,   3,   4,   5,   4,   5,   6,
             5,   4,   3,   2,   3,   4,   3,   2,   1,   2,   1,   2,   1,
             2,   3,   2,   1,   2,   1,   0,   1,   0,   1,   2,   1,   0,
             1,   0,  -1,  -2,  -1,   0,  -1,  -2,  -3,  -2,  -1,   0,   1,
             0,   1,   2,   3,   4,   5,   6,   5,   6,   7,   6,   7,   6,
             5,   6,   5,   4,   3,   2,   1,   0,   1,   0,  -1,  -2,  -3,
            -4,  -3,  -4,  -3,  -2,  -3,  -4,  -3,  -4,  -3,  -4,  -5,  -4,
            -3,  -2,  -3,  -2,  -3,  -4,  -3,  -2,  -3,  -2,  -1,   0,   1,
             0,  -1,   0,   1,   2,   1,   2,   3,   2,   3,   4,   5,   4,
             3,   2,   3,   2,   3,   2,   1,   2,   1,   0,  -1,   0,  -1,
            -2,  -3,  -4,  -3,  -4,  -5,  -4,  -5,  -6,  -7,  -6,  -5,  -4,
            -3,  -4,  -3,  -4,  -3,  -4,  -3,  -4,  -5,  -6,  -5,  -6,  -7,
            -6,  -5,  -6,  -7,  -6,  -7,  -8,  -9, -10, -11, -12, -13, -14,
           -15, -14, -13, -12, -13, -14, -15, -14, -13, -12, -11, -10,  -9,
           -10, -11, -12, -11, -10, -11, -10,  -9, -10,  -9, -10, -11, -12,
           -13, -14, -13, -12, -13, -14, -13, -14, -13, -12, -11, -12, -11,
           -12, -13, -14, -15, -14, -13, -12, -11, -10,  -9, -10, -11, -10,
            -9,  -8,  -9, -10, -11, -10, -11, -12, -13, -14, -15, -14, -15,
           -16, -15, -16, -15, -16, -17, -18, -19, -20, -21, -22, -23, -24,
           -25, -26, -25, -24, -25, -24, -25, -26, -25, -24, -25, -24, -25,
           -26, -27, -28, -29, -30, -29, -30, -29, -30, -31, -32, -31, -30,
           -29, -30, -29, -28, -27, -28, -29, -28, -29, -28, -29, -30, -29,
           -28, -27, -26, -27, -26, -27, -26, -25, -26, -27, -26, -25, -26,
           -27, -26, -27, -26, -25, -26, -25, -26, -25, -26, -25, -24, -25,
           -24, -25, -24, -25, -24, -23, -22, -21, -20, -21, -20, -21, -20,
           -19, -20, -19, -18, -19, -20, -21, -20, -19, -18, -17, -16, -17,
           -18, -17, -18, -19, -20, -21, -20, -21, -22, -21, -20, -21, -20,
           -21, -22, -23, -22, -23, -24, -23, -22, -21, -20, -21, -22, -21,
           -22, -23, -24, -23, -22, -23, -22, -23, -24, -25, -24, -25, -26,
           -25, -26, -25, -26, -27, -26, -27, -28, -27, -28, -27, -26, -27,
           -26, -25, -24, -23, -22, -23, -22, -23, -22, -21, -22, -23, -22,
           -23, -24, -25, -26, -27, -28, -27, -26, -27, -26, -25, -26, -25,
           -26, -27, -26, -25, -24, -23, -22, -23, -22, -23, -22, -21, -20,
           -19, -20, -21, -22, -23, -24, -25, -26, -25, -24, -23, -22, -21,
           -20, -19, -20, -19, -18, -19, -18, -19, -18, -17, -16, -17, -16,
           -15, -14, -13, -14, -15, -14, -15, -14, -13, -12, -13, -14, -15,
           -16, -17, -16, -15, -16, -15, -14, -13, -14, -13, -12, -13, -12,
           -13, -12, -13, -14, -13, -14, -15, -16, -15, -14, -13, -14, -13,
           -14, -15, -14, -15, -14, -13, -14, -15, -14, -13, -14, -15, -14,
           -13, -12, -11, -10, -11, -10, -11, -10,  -9,  -8,  -9, -10,  -9,
           -10, -11, -10,  -9,  -8,  -9,  -8,  -9, -10,  -9, -10, -11, -10,
           -11, -12, -13, -14, -13, -12, -11, -10,  -9, -10,  -9,  -8,  -7,
            -6,  -7,  -8,  -7,  -8,  -7,  -6,  -5,  -6,  -7,  -8,  -9,  -8,
            -7,  -6,  -7,  -6,  -5,  -6,  -7,  -6,  -5,  -6,  -7,  -6,  -5,
            -4,  -3,  -2,  -3,  -4,  -3,  -4,  -3,  -4,  -5,  -6,  -5,  -4,
            -3,  -4,  -5,  -6,  -5,  -4,  -3,  -2,  -1,  -2,  -3,  -2,  -1,
             0,   1,   2,   3,   4,   5,   4,   5,   6,   5,   6,   7,   8,
             7,   6,   7,   6,   5,   4,   5,   6,   5,   4,   5,   6,   5,
             4,   3,   2,   1,   0,   1,   0,   1,   0,  -1,   0,  -1,   0,
            -1,   0,   1,   0,   1,   0,  -1,   0,  -1,   0,   1,   0,   1,
             0,  -1,  -2,  -1,   0,   1,   2,   3,   4,   3,   4,   5,   6,
             5,   6,   5,   4,   3,   4,   5,   6,   5,   6,   7,   8])



有了这些数据之后就可以做一些统计工作了如最大最小值


```python
walk.max()
```




    8




```python
walk.min()
```




    -32



现在来看一个复杂点的统计任务--首次穿越时间，就是随机漫步过程中第一次达到某个特定值的时间。假设我们想要知道本次随机漫步需要多久才能距离初始0点至少10步远(任意方向)np.abs(walk)>=10可以得到一个布尔型数组，它表示的是距离是否达到或超过10，而我们想知道的是第一个10或-10的索引。可以用argmax来解决这个问题，它返回的是该布尔型数组第一个最大值的索引(True就是最大值):


```python
np.abs(walk)>=10   # np.abs()是元素级的，加上判断得到的是一个布尔型数组
```




    array([False, False, False, False, False, False, False, False, False,
           False, False, False, False, False, False, False, False, False,
           False, False, False, False, False, False, False, False, False,
           False, False, False, False, False, False, False, False, False,
           False, False, False, False, False, False, False, False, False,
           False, False, False, False, False, False, False, False, False,
           False, False, False, False, False, False, False, False, False,
           False, False, False, False, False, False, False, False, False,
           False, False, False, False, False, False, False, False, False,
           False, False, False, False, False, False, False, False, False,
           False, False, False, False, False, False, False, False, False,
           False, False, False, False, False, False, False, False, False,
           False, False, False, False, False, False, False, False, False,
           False, False, False, False, False, False, False, False, False,
           False, False, False, False, False, False, False, False, False,
           False, False, False, False, False, False, False, False, False,
           False, False, False, False, False, False, False, False, False,
           False, False, False, False, False, False, False, False, False,
           False, False, False, False, False, False, False, False, False,
           False, False, False, False, False, False, False, False, False,
           False, False, False, False, False, False, False, False, False,
           False, False, False, False, False, False, False, False, False,
           False, False, False, False, False, False, False, False, False,
           False, False, False, False, False, False, False, False, False,
           False, False, False, False, False, False, False, False, False,
           False, False, False, False, False, False, False, False, False,
           False, False, False, False, False, False, False, False, False,
           False, False, False, False, False, False, False, False, False,
           False, False, False, False, False, False, False, False, False,
           False, False, False, False, False, False, False, False, False,
           False, False, False, False, False, False, False, False, False,
           False, False, False, False, False, False, False, False, False,
           False, False, False, False, False, False, False, False, False,
           False, False, False, False, False, False, False, False, False,
           False, False, False, False, False, False, False, False, False,
           False, False, False, False, False, False, False, False, False,
           False, False, False, False, False, False, False, False, False,
           False, False, False, False, False, False, False, False, False,
           False, False, False, False, False, False, False, False, False,
           False, False, False, False, False, False, False, False, False,
           False, False, False, False, False, False, False, False, False,
           False, False, False, False, False, False, False, False, False,
           False, False, False, False, False, False, False, False, False,
           False, False, False, False, False, False, False, False, False,
           False, False, False, False, False, False, False, False, False,
           False, False, False, False, False, False, False, False, False,
           False, False, False, False, False, False, False, False, False,
           False, False, False, False, False, False, False, False, False,
           False, False, False, False, False, False, False, False, False,
           False, False, False, False, False, False, False, False, False,
           False, False, False, False, False, False, False, False, False,
           False, False, False, False, False, False, False, False, False,
           False, False, False, False, False, False, False, False, False,
           False, False, False, False, False, False, False, False, False,
           False, False, False,  True,  True,  True,  True,  True,  True,
            True,  True,  True,  True,  True,  True,  True,  True,  True,
            True,  True, False,  True,  True,  True,  True,  True,  True,
            True, False,  True, False,  True,  True,  True,  True,  True,
            True,  True,  True,  True,  True,  True,  True,  True,  True,
            True,  True,  True,  True,  True,  True,  True,  True,  True,
            True,  True, False,  True,  True,  True, False, False, False,
            True,  True,  True,  True,  True,  True,  True,  True,  True,
            True,  True,  True,  True,  True,  True,  True,  True,  True,
            True,  True,  True,  True,  True,  True,  True,  True,  True,
            True,  True,  True,  True,  True,  True,  True,  True,  True,
            True,  True,  True,  True,  True,  True,  True,  True,  True,
            True,  True,  True,  True,  True,  True,  True,  True,  True,
            True,  True,  True,  True,  True,  True,  True,  True,  True,
            True,  True,  True,  True,  True,  True,  True,  True,  True,
            True,  True,  True,  True,  True,  True,  True,  True,  True,
            True,  True,  True,  True,  True,  True,  True,  True,  True,
            True,  True,  True,  True,  True,  True,  True,  True,  True,
            True,  True,  True,  True,  True,  True,  True,  True,  True,
            True,  True,  True,  True,  True,  True,  True,  True,  True,
            True,  True,  True,  True,  True,  True,  True,  True,  True,
            True,  True,  True,  True,  True,  True,  True,  True,  True,
            True,  True,  True,  True,  True,  True,  True,  True,  True,
            True,  True,  True,  True,  True,  True,  True,  True,  True,
            True,  True,  True,  True,  True,  True,  True,  True,  True,
            True,  True,  True,  True,  True,  True,  True,  True,  True,
            True,  True,  True,  True,  True,  True,  True,  True,  True,
            True,  True,  True,  True,  True,  True,  True,  True,  True,
            True,  True,  True,  True,  True,  True,  True,  True,  True,
            True,  True,  True,  True,  True,  True,  True,  True,  True,
            True,  True,  True,  True,  True,  True,  True,  True,  True,
            True,  True,  True,  True,  True,  True,  True,  True,  True,
            True,  True,  True,  True,  True,  True,  True,  True,  True,
            True,  True,  True,  True,  True,  True,  True,  True,  True,
            True,  True,  True,  True,  True,  True,  True,  True,  True,
            True,  True,  True,  True,  True,  True,  True,  True,  True,
            True,  True,  True,  True,  True,  True,  True,  True,  True,
            True,  True,  True,  True,  True,  True,  True,  True,  True,
            True,  True,  True,  True,  True,  True,  True,  True,  True,
            True,  True,  True, False, False, False,  True, False,  True,
            True,  True, False, False, False, False, False,  True, False,
            True,  True,  True,  True,  True,  True,  True,  True,  True,
            True,  True, False,  True, False, False, False, False, False,
           False, False, False, False, False, False, False, False, False,
           False, False, False, False, False, False, False, False, False,
           False, False, False, False, False, False, False, False, False,
           False, False, False, False, False, False, False, False, False,
           False, False, False, False, False, False, False, False, False,
           False, False, False, False, False, False, False, False, False,
           False, False, False, False, False, False, False, False, False,
           False, False, False, False, False, False, False, False, False,
           False, False, False, False, False, False, False, False, False,
           False, False, False, False, False, False, False, False, False,
           False, False, False, False, False, False, False, False, False,
           False, False, False, False, False, False, False, False, False,
           False, False, False, False, False, False, False, False, False,
           False, False, False, False, False, False, False, False, False,
           False])




```python
(np.abs(walk)>=10).argmax()
```




    489



注，这里使用argmax并不是很高效，以为无论如何都会对数组进行完全扫描。在本例中，只要发现了一个True，那我们就真的它是个最大值了

# 一次模拟多个随机漫步
如果你希望模拟多个随机漫步过程(如5000个)，只需对上面代码做一点点修改即可生成所以的随机漫步过程。只要给numpy.random的函数传入一个 二元元组 
就可以产生一个二维数组，然后我们就可以一次性计算5000个随机漫步过程(一行一个)的累计和了:


```python
nwalks = 5000
nsteps = 1000
```


```python
draws = np.random.randint(0,2,size=(nwalks,nsteps))  # 0或1
draws
```




    array([[1, 1, 1, ..., 1, 0, 0],
           [1, 0, 0, ..., 1, 1, 1],
           [1, 1, 0, ..., 1, 1, 1],
           ...,
           [0, 0, 0, ..., 0, 1, 1],
           [0, 0, 1, ..., 0, 1, 1],
           [0, 1, 1, ..., 0, 0, 0]])




```python
steps = np.where(draws>0,1,-1)
steps
```




    array([[ 1,  1,  1, ...,  1, -1, -1],
           [ 1, -1, -1, ...,  1,  1,  1],
           [ 1,  1, -1, ...,  1,  1,  1],
           ...,
           [-1, -1, -1, ..., -1,  1,  1],
           [-1, -1,  1, ..., -1,  1,  1],
           [-1,  1,  1, ..., -1, -1, -1]])




```python
walks = steps.cumsum(1)  # 1表示按行累加
walks
```




    array([[  1,   2,   3, ..., -10, -11, -12],
           [  1,   0,  -1, ...,   4,   5,   6],
           [  1,   2,   1, ..., -48, -47, -46],
           ...,
           [ -1,  -2,  -3, ..., -20, -19, -18],
           [ -1,  -2,  -1, ..., -24, -23, -22],
           [ -1,   0,   1, ..., -58, -59, -60]])



现在，我们来计算所有随机漫步过程的最大值和最小值:


```python
walks.max()
```




    120




```python
walks.min()
```




    -120



得到这些数据后，我们来计算30或-30的最小穿越时间。
注意！这里需要思考一下，因为不是5000个过程都到达了30。我们可以用any方法(如果有一个或多个True就返回True)来对此进行检查:


```python
hits30 = (np.abs(walks)>=30).any(1)  # 以行来检查
hits30 # 里面True即表示这次随机漫步有大于30的步数
```




    array([False,  True,  True, ...,  True,  True,  True])




```python
hits30.sum()  # 返回的是True的数量即到达30或-30的数量
```




    3379



然后我们利用这个布尔型数组选出那些超越了30(绝对值)的随机漫步(行)，并调用argmax在轴1上获取穿越时间


```python
walks[hits30] # 有超过30的行
```




    array([[  1,   0,  -1, ...,   4,   5,   6],
           [  1,   2,   1, ..., -48, -47, -46],
           [ -1,   0,  -1, ...,  -4,  -5,  -4],
           ...,
           [ -1,  -2,  -3, ..., -20, -19, -18],
           [ -1,  -2,  -1, ..., -24, -23, -22],
           [ -1,   0,   1, ..., -58, -59, -60]])




```python
np.abs(walks[hits30])>=30  # 将这些行转换成布尔型，然后用argmax()判断
```




    array([[False, False, False, ..., False, False, False],
           [False, False, False, ...,  True,  True,  True],
           [False, False, False, ..., False, False, False],
           ...,
           [False, False, False, ..., False, False, False],
           [False, False, False, ..., False, False, False],
           [False, False, False, ...,  True,  True,  True]])




```python
crossing_times = (np.abs(walks[hits30])>=30).argmax(1)
crossing_times  # 记录的是满足的行里分别是在第几个索引位置达到30
```




    array([251, 133, 685, ..., 231, 867, 487], dtype=int64)




```python
crossing_times.mean()
```




    500.7650192364605



当然我们也可以同其他分布方式得到漫步数据，只需要使用不同的随机数生成函数，如mormal用于生成指定均值和标准差的正态分布数据：



```python
steps = np.random.normal(loc=0,scale=0.25,size=(nwalks,nsteps))
```

...
